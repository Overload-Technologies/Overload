vec3 UnPack(float target)
{
    return vec3 (
        float((uint(target) >> 24) & 0xff) * 0.003921568627451,
        float((uint(target) >> 16) & 0xff) * 0.003921568627451,
        float((uint(target) >> 8) & 0xff) * 0.003921568627451
    );
}

vec2 TileAndOffsetTexCoords(vec2 texCoords, vec2 tiling, vec2 offset)
{
    return vec2(mod(texCoords.x * tiling.x, 1), mod(texCoords.y * tiling.y, 1)) + offset;
}

// Expects a height map with values in the range [0, 1].
// 1.0 means the height is at the maximum depth, 0.0 means the height is at the minimum depth.
vec2 ApplyParallaxOcclusionMapping(vec2 texCoords, sampler2D heightMap, vec3 tangentViewPos, vec3 tangentFragPos, float heightScale)
{
    const vec3 viewDir = normalize(tangentViewPos - tangentFragPos);

    // number of depth layers
    const float minLayers = 8;
    const float maxLayers = 64;
    const float numLayers = mix(maxLayers, minLayers, abs(dot(vec3(0.0, 0.0, 1.0), viewDir)));  

    // calculate the size of each layer
    const float layerDepth = 1.0 / numLayers;
    // the amount to shift the texture coordinates per layer (from vector P)
    const vec2 P = viewDir.xy / viewDir.z * heightScale; 
    const vec2 deltaTexCoords = P / numLayers;
  
    // get initial values
    vec2 currentTexCoords = texCoords;
    float currentDepthMapValue = 1.0 - texture(heightMap, currentTexCoords).r;
    float currentLayerDepth = 0.0;
      
    while(currentLayerDepth < currentDepthMapValue)
    {
        // shift texture coordinates along direction of P
        currentTexCoords -= deltaTexCoords;
        // get depthmap value at current texture coordinates
        currentDepthMapValue = 1.0 - texture(heightMap, currentTexCoords).r;
        // get depth of next layer
        currentLayerDepth += layerDepth;
    }
    
    // get texture coordinates before collision (reverse operations)
    const vec2 prevTexCoords = currentTexCoords + deltaTexCoords;

    // get depth after and before collision for linear interpolation
    const float afterDepth  = currentDepthMapValue - currentLayerDepth;
    const float beforeDepth = 1.0 - texture(heightMap, prevTexCoords).r - currentLayerDepth + layerDepth;
 
    // interpolation of texture coordinates
    const float weight = afterDepth / (afterDepth - beforeDepth);
    const vec2 finalTexCoords = prevTexCoords * weight + currentTexCoords * (1.0 - weight);

    return finalTexCoords;
}

// [Deprecated] Kept for backward compatibility. Prefer using `ApplyParallaxOcclusionMapping()` instead.
vec2 ApplyParallaxMapping(vec2 texCoords, sampler2D heightMap, vec3 tangentViewPos, vec3 tangentFragPos, float heightScale)
{
    if (heightScale > 0)
    {
        const vec3 viewDir = normalize(tangentViewPos - tangentFragPos);
        const vec2 parallax = viewDir.xy * heightScale * texture(heightMap, texCoords).r;
        return texCoords - vec2(parallax.x, 1.0 - parallax.y);
    }

    return texCoords;
}

// [Deprecated] Kept for backward compatibility.
bool IsMasked(sampler2D maskMap, vec2 texCoords)
{
    return texture(maskMap, texCoords).r == 0.0;
}

mat3 ConstructTBN(mat4 model, vec3 normal, vec3 tangent, vec3 bitangent)
{
   return mat3(
        normalize(vec3(model * vec4(tangent,   0.0))),
        normalize(vec3(model * vec4(bitangent, 0.0))),
        normalize(vec3(model * vec4(normal,    0.0)))
    );
}


vec3 ComputeNormal(vec2 texCoords, vec3 normal, sampler2D normalMap, mat3 TBN)
{
    normal = texture(normalMap, texCoords).rgb;
    normal = normalize(normal * 2.0 - 1.0);
    normal = normalize(TBN * normal);
    return normal;
}

// [Deprecated] Kept for backward compatibility. Prefer using `ComputeNormal()` without the `enableNormalMapping` parameter,
// and handle branching using preprocessor directives instead.
vec3 ComputeNormal(bool enableNormalMapping, vec2 texCoords, vec3 normal, sampler2D normalMap, mat3 TBN)
{
    if (enableNormalMapping)
    {
        return ComputeNormal(texCoords, normal, normalMap, TBN);
    }

    return normalize(normal);
}
