#shader vertex
#version 430 core

layout(location = 0) in vec2 geo_Pos;
layout(location = 1) in vec2 geo_TexCoords;

out vec2 TexCoords;

void main()
{
    TexCoords = geo_TexCoords;
    gl_Position = vec4(geo_Pos, 0.0, 1.0);
}

#shader fragment
#version 430 core

in vec2 TexCoords;
out vec4 FRAGMENT_COLOR;

uniform sampler2D _InputTexture;
uniform sampler2D _LuminanceTexture;
uniform float _MinLumianceEV;
uniform float _MaxLuminanceEV;
uniform float _ExposureCompensationEV;
uniform float _ElapsedTime;
uniform float _SpeedUp;
uniform float _SpeedDown;
uniform int _Progressive;

// Photographic Middle Gray Reference
const float MIDDLE_GRAY = 0.18f;

// Standard Luminance Coefficients (Rec. 709)
const vec3 LUMINANCE_COEFFS = vec3(0.2126f, 0.7152f, 0.0722f);

// ISO Reference Value
const float ISO_REFERENCE = 100.0f;

// Aperture Reference
const float APERTURE_REFERENCE = 1.0f;

// To avoid division by zero and log2 of zero
const float EPSILON = 0.0001f;

float SafeLog2(float x)
{
    return log2(max(x, EPSILON));
}

// Convert Luminance to Exposure Value (EV100)
float LuminanceToEV100(float luminance)
{
    // EV100 = log2(L * ISO / (K * S))
    // Where:
    // L = Luminance in cd/m²
    // K = Light meter calibration constant (typically 12.5)
    // S = ISO sensitivity
    // Using simplified derivation for standard scene luminance
    return SafeLog2(luminance / (MIDDLE_GRAY * ISO_REFERENCE / 100.0f)) * 2.0f;
}

// Convert EV100 back to Luminance
float EV100ToLuminance(float ev100)
{
    // Reverse of LuminanceToEV100
    return exp2(ev100 * 0.5f) * (MIDDLE_GRAY * ISO_REFERENCE / 100.0f);
}

// Advanced Exposure Calculation
float CalculateExposureMultiplier(float luminance, float minLuminanceEV, float maxLuminanceEV, float exposureCompensation) 
{
    // Convert average luminance to EV100
    float luminanceEV = LuminanceToEV100(luminance);
    
    // Clamp EV within specified range
    float clampedLuminanceEV = clamp(luminanceEV, minLuminanceEV, maxLuminanceEV);
    
    // Apply exposure compensation
    float compensatedEV = clampedLuminanceEV - exposureCompensation;
    
    // Calculate exposure multiplier
    // Using middle gray as reference, with protection against extreme values
    float exposureMultiplier = MIDDLE_GRAY / max(EV100ToLuminance(compensatedEV), EPSILON);
    
    return exposureMultiplier;
}

float InterpolateExposure(float newExposure, float oldExposure)
{
    if (_Progressive != 0)
    {
        const float delta = newExposure - oldExposure;
        const float speed = delta > 0.0 ? _SpeedUp : _SpeedDown;
        return oldExposure + delta * (1.0 - exp2(-_ElapsedTime * speed));
    }
    else
    {
        return newExposure;
    }
}

void main()
{
    const float averageLuminance = textureLod(_LuminanceTexture, vec2(0.5), textureQueryLevels(_LuminanceTexture) - 1).r;
    const float newExposure = CalculateExposureMultiplier(averageLuminance, _MinLumianceEV, _MaxLuminanceEV, _ExposureCompensationEV);
    const float previousExposure = max(texture(_InputTexture, vec2(0.5)).r, 0.0001);
    const float interpolatedExposure = InterpolateExposure(newExposure, previousExposure);
    FRAGMENT_COLOR = vec4(vec3(interpolatedExposure), 1.0);
}
